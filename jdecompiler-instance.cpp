#ifndef JDECOMPILER_JDECOMPILER_INSTANCE_CPP
#define JDECOMPILER_JDECOMPILER_INSTANCE_CPP

#include <filesystem>
#include <dlfcn.h>
#include "util.h"
#include "jvm.h"
#include "class-holder.cpp"

#ifndef JDECOMPILER_VERSION
#define JDECOMPILER_VERSION "unknown"
#endif

#ifdef __unix__
#	define LIBJVM_PATH "jvm.so"
#	define SYSTEM_LIBJVM_PATH "libjvm.so"
#elif defined(__WIN32) || defined(_WIN32)
#	define LIBJVM_PATH "jvm.dll"
#	define SYSTEM_LIBJVM_PATH "libjvm.dll"
#else
#	error "Unsupported system: so far, only windows and unix are supported"
#endif

namespace jdecompiler {

	namespace filesystem = std::filesystem;


	struct JDecompiler {

		protected:
			static const JDecompiler* instance;

			vector<ClassInputStream*> files;

			string progName;

			string indent = "    ";

			bool atLeastOneFileSpecified = false;
			bool canPrintClassVersion = true;

			bool canWriteToConsole = false;

			enum class ConstantsUsage { ALWAYS, MINIMAL, NEVER };

			ConstantsUsage useConstants = ConstantsUsage::ALWAYS;
			bool useCustomConstants = true;

			enum class HexUsage { ALWAYS, AUTO, NEVER };
			HexUsage useHexNumbers = HexUsage::NEVER;

			bool canShowSynthetic = false, canShowBridge = false, canShowAutogenerated = false;
			bool canUseDoublePostfix = true, canUseTrailingZero = false;
			char longPostfix = 'l', floatPostfix = 'f', doublePostfix = 'd';

			bool isMultilineStringAllowed = true;
			bool canUseOverrideAnnotation = true;
			bool canOmitReferenceToThis = true;

			bool canUseShortArrayInitializing = true;
			bool canUseCStyleArrayDeclaration = false;
			bool canCastWrappers = true;
			bool canPrintNewLineInParameterAnnotations = true;
			bool canOmitBrackets = true;

			mutable umap<string, ClassHolder> decompilationClasses;
			mutable umap<string, const Class*> classes;

			friend struct Class;

		private:
			static const JVM* jvm;
			static void *libJvm, *systemLibJvm;
			friend void finish();

			const JVM* loadJvm(const char* javaHome) {

				if(javaHome == nullptr)
					return nullptr;

				/* I can't specify the LD_LIBRARY_PATH environment variable since it is not specified for the external context.
				 * Therefore, I have to load the libjvm library manually */
				static constexpr const char* SYSTEM_LIBJVM_PATHS[] = {
					#ifdef __unix__
						"/server/", "/lib/server/", "/lib/amd64/server/", "/jre/lib/amd64/server/", "/" // Also check if file contains in javaHome directly
					#elif defined(__WIN32) || defined(_WIN32)
						"\\bin\\server\\", "\\bin\\client\\", "\\"
					#	warning "Check path to java in this system"
					#else
					#	error "Other systems than unix or windows are not supported yet"
					#endif
				};

				const size_t systemLibJvmPathOffset = javaHome[strlen(javaHome) - 1] == filesystem::path::preferred_separator ? 1 : 0;

				for(const char* systemLibJvmPath : SYSTEM_LIBJVM_PATHS) {
					char* fullPath = str_concat(javaHome, systemLibJvmPath + systemLibJvmPathOffset, SYSTEM_LIBJVM_PATH);
					systemLibJvm = dlopen(fullPath, RTLD_LAZY);
					delete[] fullPath;

					if(systemLibJvm != nullptr)
						break;
				}


				if(systemLibJvm == nullptr) {
					error("cannot load dynamic library " SYSTEM_LIBJVM_PATH ": ", dlerror());
					return nullptr;
				}


				// Load custom jvm library

				libJvm = dlopen(LIBJVM_PATH, RTLD_LAZY);

				if(libJvm == nullptr) {
					error("cannot load dynamic library " LIBJVM_PATH ": ", dlerror());
					return nullptr;
				}


				const JVM*(*createJvm)() = (const JVM*(*)())dlsym(libJvm, "createJDecompilerJvm");

				if(createJvm == nullptr) {
					error("cannot find function createJDecompilerJvm in library " LIBJVM_PATH ": ", dlerror());
					return nullptr;
				}

				return createJvm();
			}

		protected:
			static bool initSuccess;

			JDecompiler(int argc, const char* args[]) {
				const string progName(args[0] + string(args[0]).find_last_of(filesystem::path::preferred_separator) + 1);
				this->progName = progName;

				const char* javaHome = getenv("JAVA_HOME");


				if(argc <= 1) {
					cout << "Usage: " << progName << " [options] <class-files>" << endl;
					initSuccess = false;
					return;
				}

				#define printError(...) cerr << progName << ": error: " << __VA_ARGS__ << endl
				#define printErrorAndExit(...) {\
					printError(__VA_ARGS__);\
					initSuccess = false;\
					return;\
				}

				#define requireValue() {\
					if(!hasValue) {\
						printErrorAndExit("option " << option << " required value");\
					}\
					i++;\
				}

				bool atLeastOneFileSpecified = false;

				for(int i = 1; i < argc; i++) {
					const string arg = args[i];
					const size_t length = arg.size();

					if(length > 1 && arg[0] == '-') {

						string option, value;
						bool hasValue = false, hasValueWeak = false;
						const auto splitpos = arg.find('=');

						if(splitpos != string::npos) {
							option = string(arg, 0, splitpos);
							value = string(arg.begin() + splitpos + 1, arg.end());
							hasValue = hasValueWeak = true;
						} else {
							option = arg;
							if(i + 1 < argc) {
								value = args[i + 1];
								hasValue = true;
							}
						}


						if(option == "-h" || option == "--help" || option == "-?") {
							cout << "Usage: " << progName << " [options] <class-files>\n"
							"\n"
							"----------------------------------------------- Options ------------------------------------------------\n"
							"General:\n"
							"  -h, --help, -?                        show this message and exit\n"
							"  -v, --version                         show program version\n"
							//"  -d, --dir=<directory>                 specify directory to place decompiled files\n"
							"  --java-home=<path/to/java>            specify the java home path (if JAVA_HOME env var is not set)\n"
							"\n"
							"Decompilation of constants:\n"
							"  -c, --use-constants[=auto|min|never]  use constants:\n"
							"                                auto      use for all standart constants (MAX_VALUE, MIN_VALUE, etc.)\n"
							"                                 min      use for only POSITIVE_INFINITY, NEGATIVE_INFINITY and NaN\n"
							"                               never      don't use constants at all\n"
							"  --no-custom-consts                    don't use custom constants (which declared in decompiled class)\n"
							"  --min-consts                          the same as --use-constants=min\n"
							"  --no-consts                           the same as --use-constants=never\n"
							"\n"
							"  --synthetic                           show synthetic fields, methods and classes generated by compiler\n"
							"  --bridge                              show bridge methods generated by compiler\n"
							"  --autogenerated                       show methods autogenerated by compiler\n"
							"                                          (such as Enum.valueOf(String) or constructor by default)\n"
							"  -a, --all-autogenerated               show synthetic, bridge and autogenerated fields, methods and classes\n"
							"\n"
							"Text formatting:\n"
							"  -V, --no-print-version                  do not print class file version at the top of each file\n"
							"  -i=<indent>, --indent=<indent>          set indent (by default four spaces)\n"
							"  -t, --tab                               use tabs (equivalent to --indent='\\t')\n"
							"\n"
							"  -x, --hex[=always|auto|never]         use hex numbers:\n"
							"                              always      always use\n"
							"                                auto      only use for values like 0x7F, 0x80 and 0xFF\n"
							"                               never      do not use (by default)\n"
							"\n"
							"  -D  --no-double-postfix                 not use postfix 'd' in double literals\n"
							"  -u, --upper-postfixes                   use upper postfixes in long, float and double literals\n"
							"  -l, --lower-postfixes                   use lower postfixes\n"
							"  -z, --use-trailing-zero                 use trailing zero in float or double literals if it is integral number\n"
							"                                             (note: if double literal has no prefix, trailing zero will be used in any case)\n"
							"  -M, --no-multiline                      not split multiline string constants\n"
							"  -O, --no-override-annotation            do not use java.lang.Override annotation\n"
							"  --this, --no-omit-this-ref              do not omit the reference to this\n"
							"\n"
							"  --no-short-array-init                   do not use short array initialization in the variable declaration\n"
							"  --c-style-arrays                        use C-style array declaration\n"
							"  --no-cast-wrappers                      do not replace methods such as Integer.valueOf and Integer.intValue\n"
							"                                            to cast to Integer and to int, respectively\n"
							"  --no-new-line-in-parameter-annotations  don't print new line when decompiling the annotation on the method argument\n"
							"  --no-omit-brackets                      do not omit brackets in if and for constructions\n"
							<< endl;

							initSuccess = false;
							return;

						} else if(option == "--java-home") {
							requireValue();
							javaHome = strdup(value.c_str());

						} else if(option == "-o-") {
							canWriteToConsole = true;

						} else if(option == "-v" || option == "--version") {
							cout << "JDecompiler version " JDECOMPILER_VERSION << endl;

							initSuccess = false;
							return;

						} else if(option == "-V" || option == "--no-print-version") {
							canPrintClassVersion = false;

						} else if(option == "-i" || option == "--indent") {
							requireValue();
							indent = unescapeString(value);

						} else if(option == "-t" || option == "--tab") {
							indent = "\t";

						} else if(option == "-c" || option == "--use-constants") {
							requireValue();

							if(value == "always")
								useConstants = ConstantsUsage::ALWAYS;
							else if(value == "min")
								useConstants = ConstantsUsage::MINIMAL;
							else if(value == "never")
								useConstants = ConstantsUsage::NEVER;
							else
								printErrorAndExit("invalid value for option " << option << ": only valid always, min or never");

						} else if(option == "--no-custom-consts") {
							useCustomConstants = false;

						} else if(option == "--min-consts") {
							useConstants = ConstantsUsage::MINIMAL;

						} else if(option == "--no-consts") {
							useConstants = ConstantsUsage::NEVER;

						} else if(option == "-x" || option == "--hex") {
							if(hasValueWeak) {
								if(value == "always")     useHexNumbers = HexUsage::ALWAYS;
								else if(value == "auto")  useHexNumbers = HexUsage::AUTO;
								else if(value == "never") useHexNumbers = HexUsage::NEVER;
								else printErrorAndExit("invalid value for option " << option << ": only valid always, auto or never");
							} else {
								useHexNumbers = HexUsage::AUTO;
							}

						} else if(option == "--synthetic") {
							canShowSynthetic = true;
						} else if(option == "--bridge") {
							canShowBridge = true;
						} else if(option == "--autogenerated") {
							canShowAutogenerated = true;
						} else if(option == "-a" || option == "--all-autogenerated") {
							canShowSynthetic = true;
							canShowBridge = true;
							canShowAutogenerated = true;
						} else if(option == "-D" || option == "--no-double-postfix") {
							canUseDoublePostfix = false;
						} else if(option == "-z" || option == "--use-trailing-zero") {
							canUseTrailingZero = true;
						} else if(option == "-u" || option == "--upper-postfixes") {
							longPostfix = 'L';
							floatPostfix = 'F';
							doublePostfix = 'D';
						} else if(option == "-l" || option == "--lower-postfixes") {
							longPostfix = 'l';
							floatPostfix = 'f';
							doublePostfix = 'd';
						} else if(option == "-M" || option == "--no-multiline") {
							isMultilineStringAllowed = false;
						} else if(option == "-O" || option == "--no-override-annotation") {
							canUseOverrideAnnotation = false;
						} else if(option == "--this" || option == "--no-omit-ref-to-this") {
							canOmitReferenceToThis = false;
						} else if(option == "--no-short-array-init") {
							canUseShortArrayInitializing = false;
						} else if(option == "--c-style-arrays") {
							canUseCStyleArrayDeclaration = true;
						} else if(option == "--no-cast-wrappers") {
							canCastWrappers = false;
						} else if(option == "--no-new-line-in-parameter-annotations") {
							canPrintNewLineInParameterAnnotations = false;
						} else if(option == "--no-omit-brackets") {
							canOmitBrackets = false;
						} else {
							printErrorAndExit("Unknown argument " << arg << "\n"
								"Use " << progName << " --help for more information");
						}
					} else {
						atLeastOneFileSpecified = true;
						try {
							files.push_back(new ClassInputStream(*new FileBinaryInputStream(arg)));
						} catch(const IOException& ex) {
							printError(ex.toString());
						}
					}
				}

				this->atLeastOneFileSpecified = atLeastOneFileSpecified;

				#undef requireValue
				#undef printErrorAndExit
				#undef printError

				jvm = loadJvm(javaHome);
			}



		public:
			static const JDecompiler& getInstance() {
				if(instance == nullptr)
					throw IllegalStateException("JDecompiler yet not initialized");
				return *instance;
			}

			static bool init(int argc, const char* args[]) {
				if(instance != nullptr)
					throw IllegalStateException("JDecompiler already initialized");

				instance = new JDecompiler(argc, args);

				return initSuccess;

			}


			inline bool printClassVersion() const {
				return canPrintClassVersion;
			}

			inline const string& getIndent() const {
				return indent;
			}

			inline bool writeToConsole() const {
				return canWriteToConsole;
			}

			inline bool canUseConstants() const {
				return useConstants == ConstantsUsage::ALWAYS;
			}

			inline bool canUseCustomConstants() const {
				return useCustomConstants;
			}

			inline bool canUseNaNAndInfinity() const {
				return useConstants == ConstantsUsage::ALWAYS || useConstants == ConstantsUsage::MINIMAL;
			}

			inline bool canUseHexNumbers() const {
				return useHexNumbers == HexUsage::AUTO || useHexNumbers == HexUsage::ALWAYS;
			}

			inline bool useHexNumbersAlways() const {
				return useHexNumbers == HexUsage::ALWAYS;
			}

			inline bool showSynthetic() const {
				return canShowSynthetic;
			}

			inline bool showBridge() const {
				return canShowBridge;
			}

			inline bool showAutogenerated() const {
				return canShowAutogenerated;
			}

			inline bool useDoublePostfix() const {
				return canUseDoublePostfix;
			}

			inline bool useTrailingZero() const {
				return canUseTrailingZero;
			}

			inline char getLongPostfix() const {
				return longPostfix;
			}

			inline char getFloatPostfix() const {
				return floatPostfix;
			}

			inline char getDoublePostfix() const {
				return doublePostfix;
			}

			inline bool multilineStringAllowed() const {
				return isMultilineStringAllowed;
			}

			inline bool useOverrideAnnotation() const {
				return canUseOverrideAnnotation;
			}

			inline bool omitReferenceToThis() const {
				return canOmitReferenceToThis;
			}

			inline bool useShortArrayInitializing() const {
				return canUseShortArrayInitializing;
			}

			inline bool useCStyleArrayDeclaration() const {
				return canUseCStyleArrayDeclaration;
			}

			inline bool castWrappers() const {
				return canCastWrappers;
			}

			inline bool printNewLineInParameterAnnotations() const {
				return canPrintNewLineInParameterAnnotations;
			}

			inline bool omitBrackets() const {
				return canOmitBrackets;
			}


			inline const vector<ClassInputStream*>& getFiles() const {
				return files;
			}

			void readClassFiles() const;

			inline const umap<string, ClassHolder>& getDecompilationClasses() const {
				return decompilationClasses;
			}

			inline const umap<string, const Class*>& getClasses() const {
				return classes;
			}

			inline const Class* getClass(const string& name) const {
				const auto& classIterator = classes.find(name);
				return classIterator != classes.end() ? classIterator->second :
						classes[name] = (jvm != nullptr ? jvm->loadClass(name.c_str()) : nullptr);
			}

			const ClassInfo* getClassInfo(const string& name) const;

			inline bool hasClass(const string& name) const {
				return getClass(name) != nullptr;
			}

		protected:
			template<typename Arg, typename... Args>
			static inline void print(ostream& out, Arg arg, Args... args) {
				if constexpr(sizeof...(Args) > 0)
					print(out << arg, args...);
				else
					out << arg << endl;
			}

		private:
			template<typename... Args>
			inline void error(Args... args) const {
				print(cerr << progName << ": error: ", args...);
			}
	};

	const JDecompiler* JDecompiler::instance = nullptr;
	const JVM* JDecompiler::jvm = nullptr;
	void *JDecompiler::libJvm = nullptr,
	     *JDecompiler::systemLibJvm = nullptr;
	bool JDecompiler::initSuccess = true;
}

#endif
