#ifndef JDECOMPILER_JDECOMPILER_INSTANCE_CPP
#define JDECOMPILER_JDECOMPILER_INSTANCE_CPP

#include <filesystem>
#include "util.cpp"

#ifndef JDECOMPILER_VERSION
#define JDECOMPILER_VERSION "unknown"
#endif

namespace jdecompiler {

	struct JDecompiler {

		protected:
			static const JDecompiler* instance;


			const string progName;

			const vector<ClassInputStream*> files;
			const bool atLeastOneFileSpecified;

			const char* const indent;

			const bool failOnError;

			enum class ConstantsUsage { ALWAYS, MINIMAL, NEVER };
			const ConstantsUsage useConstants;
			const bool useCustomConstants;

			enum class HexUsage { ALWAYS, AUTO, NEVER };
			const HexUsage useHexNumbers;

			const bool useShortArrayInitializing;
			const bool canCastWrappers;
			const bool canShowSynthetic, canShowBridge, canShowAutogenerated;
			const bool canUseDoublePostfix, canUseTrailingZero;
			const char longPostfix, floatPostfix, doublePostfix;

			const bool isMultilineStringAllowed;
			const bool canUseOverrideAnnotation;

			mutable map<string, const Class*> classes;

			JDecompiler(const string progName, const vector<ClassInputStream*>& files, bool atLeastOneFileSpecified, const char* indent,
					bool failOnError, ConstantsUsage useConstants, bool useCustomConstants, HexUsage useHexNumbers,
					bool useShortArrayInitializing, bool canCastWrappers, bool canShowSynthetic, bool canShowBridge, bool canShowAutogenerated,
					bool canUseDoublePostfix, bool canUseTrailingZero, bool upperPostfixes, bool isMultilineStringAllowed,
					bool canUseOverrideAnnotation, map<string, const Class*>& classes):

					progName(progName), files(files), atLeastOneFileSpecified(atLeastOneFileSpecified), indent(indent),
					failOnError(failOnError), useConstants(useConstants), useCustomConstants(useCustomConstants), useHexNumbers(useHexNumbers),
					useShortArrayInitializing(useShortArrayInitializing), canCastWrappers(canCastWrappers),
					canShowSynthetic(canShowSynthetic), canShowBridge(canShowBridge), canShowAutogenerated(canShowAutogenerated),
					canUseDoublePostfix(canUseDoublePostfix), canUseTrailingZero(canUseTrailingZero),
					longPostfix(upperPostfixes ? 'L' : 'l'), floatPostfix(upperPostfixes ? 'F' : 'f'), doublePostfix(upperPostfixes ? 'D' : 'd'),
					isMultilineStringAllowed(isMultilineStringAllowed), canUseOverrideAnnotation(canUseOverrideAnnotation), classes(classes) {}



		public:
			static const JDecompiler& getInstance() {
				if(instance == nullptr)
					throw IllegalStateException("JDecompiler yet not initialized");
				return *instance;
			}

			static bool init(int argc, const char* args[]) {
				if(instance != nullptr)
					throw IllegalStateException("JDecompiler already initialized");

				const string progPath = args[0];
				const string progName = progPath.substr(progPath.find_last_of(std::filesystem::path::preferred_separator) + 1);

				vector<ClassInputStream*> files;

				int_fast32_t indentWidth = 4;
				const char* indent = "    ";

				bool failOnError = false;
				ConstantsUsage useConstants = ConstantsUsage::ALWAYS;
				bool useCustomConstants = true;
				HexUsage useHexNumbers = HexUsage::NEVER;

				bool useShortArrayInitializing = true;
				bool canCastWrappers = true;
				bool canShowSynthetic = false, canShowBridge = false, canShowAutogenerated = false;
				bool canUseDoublePostfix = true, canUseTrailingZero = false;
				bool upperPostfixes = false;

				bool isMultilineStringAllowed = true;
				bool canUseOverrideAnnotation = true;

				map<string, const Class*> classes;


				if(argc <= 1) {
					cout << "Usage: " << progName << " [options] <class-files>" << endl;
					return false;
				}

				#define printError(...) cerr << progName << ": error: " << __VA_ARGS__ << endl
				#define printErrorAndExit(...) { printError(__VA_ARGS__); return false; }

				#define requireValue() {\
					if(!hasValue) {\
						printErrorAndExit("option " << option << " required value");\
						return false;\
					}\
					i++;\
				}

				bool isIndentWidthSpecified = false;

				bool atLeastOneFileSpecified = false;

				for(int i = 1; i < argc; i++) {
					const string arg = args[i];
					const size_t length = arg.size();

					if(length > 1 && arg[0] == '-') {

						string option, value;
						bool hasValue = false, hasValueWeak = false;
						const auto splitpos = arg.find('=');

						if(splitpos != string::npos) {
							option = string(arg, 0, splitpos);
							value = string(arg.begin() + splitpos + 1, arg.end());
							hasValue = hasValueWeak = true;
						} else {
							option = arg;
							if(i + 1 < argc) {
								value = args[i + 1];
								hasValue = true;
							}
						}


						if(option == "-h" || option == "--help" || option == "-?") {
							cout << "Usage: " << progName << " [options] <class-files>\n"
								"\n"
								"  -h, --help, -?                      show this message and exit\n"
								"  -v, --version                       show program version\n"
								"  -f, --fail-on-error                 fail on error (debug)\n"
								"  -w=<width>, --indent-width=<width>  set indent width (by default 4)\n"
								"  -i=<indent>, --indent=<indent>      set indent (by default four spaces)\n"
								"  -tab                                use tabs (equivalent to --indent='\\t')\n"
								"\n"
								"  --use-constants=auto|min|never      use constants:\n"
								"                                auto    use for all standart constants (MAX_VALUE, MIN_VALUE, etc.)\n"
								"                                 min    use for only POSITIVE_INFINITY, NEGATIVE_INFINITY and NaN\n"
								"                               never    don't use constants at all\n"
								"  --no-custom-consts                      don't use custom constants (which declared in decompiled class)\n"
								"  --min-consts                            the same as --use-constants=min\n"
								"  --no-consts                             the same as --use-constants=never\n"
								"  --hex[=always|auto|never]           use hex numbers:\n"
								"                              always    always use\n"
								"                                auto    only use for values like 0x7F, 0x80 and 0xFF\n"
								"                               never    do not use (by default)\n"
								"\n"
								"  --no-short-array-init               do not use short array initialization in the variable declaration\n"
								"  --no-cast-wrappers                  do not replace methods such as Integer.valueOf and Integer.intValue\n"
								"                                        to cast to Integer and to int, respectively\n"
								"  --synthetic                         show synthetic fields, methods and classes generated by compiler\n"
								"  --bridge                            show bridge methods generated by compiler\n"
								"  --autogenerated                     show methods autogenerated by compiler\n"
								"                                        (such as Enum.valueOf(String) or constructor by default)\n"
								"  -a, --all-autogenerated             show synthetic, bridge and autogenerated fields, methods and classes\n"
								"\n"
								"  -D  --no-double-postfix             not use postfix 'd' in double literals\n"
								"  -u, --upper-postfixes               use upper postfixes in long, float and double literals\n"
								"  -z, --use-trailing-zero             use trailing zero in float or double literals if it is integral number\n"
								"                                        (note: if double literal has no prefix, trailing zero will be used in any case)\n"
								"  -M, --no-multiline                  not split multiline string constants\n"
								"  -O, --no-override-annotation        do not use java.lang.Override annotation\n"
								<< endl;

							return false;

						} else if(option == "-f" || option == "--fail-on-error") {
							failOnError = true;

						} else if(option == "-v" || option == "--version") {
							cout << "JDecompiler version " JDECOMPILER_VERSION << endl;

							return false;

						} else if(option == "-w" || option == "--indent-width") {
							requireValue();
							try {
								indentWidth = stoi(value);
								if(indentWidth < 0)
									printErrorAndExit("indent width " << value << " cannot be negative");
								if(indentWidth > 16)
									printErrorAndExit("indent width " << value << " is out of range (valid values are from 0 to 16)");

								indent = repeatString(indent, indentWidth);
							} catch(const invalid_argument&) {
								printErrorAndExit("Invalid argument value: '" << value << '\'');
							} catch(const out_of_range&) {
								printErrorAndExit("Argument value '" << value << "' is out of range");
							}

							isIndentWidthSpecified = true;

						} else if(option == "-i" || option == "--indent") {
							requireValue();
							value = unescapeString(value);
							indent = repeatString(value, isIndentWidthSpecified || value != "\t" ? indentWidth : (indentWidth = 1));

						} else if(option == "-tab") {
							indent = "\t";

						} else if(option == "--use-constants") {
							requireValue();

							if(value == "always")
								useConstants = ConstantsUsage::ALWAYS;
							else if(value == "min")
								useConstants = ConstantsUsage::MINIMAL;
							else if(value == "never")
								useConstants = ConstantsUsage::NEVER;
							else
								printErrorAndExit("invalid value for option " << option << ": only valid always, min or never");

						} else if(option == "--no-custom-consts") {
							useCustomConstants = false;

						} else if(option == "--min-consts") {
							useConstants = ConstantsUsage::MINIMAL;

						} else if(option == "--no-consts") {
							useConstants = ConstantsUsage::NEVER;

						} else if(option == "--hex") {
							if(hasValueWeak) {
								if(value == "always")     useHexNumbers = HexUsage::ALWAYS;
								else if(value == "auto")  useHexNumbers = HexUsage::AUTO;
								else if(value == "never") useHexNumbers = HexUsage::NEVER;
								else printErrorAndExit("invalid value for option " << option << ": only valid always, auto or never");
							} else {
								useHexNumbers = HexUsage::AUTO;
							}

						} else if(option == "--no-short-array-init") {
							useShortArrayInitializing = false;
						} else if(option == "--no-cast-wrappers") {
							canCastWrappers = false;
						} else if(option == "--synthetic") {
							canShowSynthetic = true;
						} else if(option == "--bridge") {
							canShowBridge = true;
						} else if(option == "--autogenerated") {
							canShowAutogenerated = true;
						} else if(option == "-a" || option == "--all-autogenerated") {
							canShowSynthetic = true;
							canShowBridge = true;
							canShowAutogenerated = true;
						} else if(option == "-D" || option == "--no-double-postfix") {
							canUseDoublePostfix = false;
						} else if(option == "-z" || option == "--use-trailing-zero") {
							canUseTrailingZero = true;
						} else if(option == "-u" || option == "--upper-postfixes") {
							upperPostfixes = true;
						} else if(option == "-M" || option == "--no-multiline") {
							isMultilineStringAllowed = false;
						} else if(option == "-O" || option == "--no-override-annotation") {
							canUseOverrideAnnotation = false;
						} else {
							printErrorAndExit("Unknown argument " << arg << "\n"
								"Use " << progName << " --help for more information");
						}
					} else {
						atLeastOneFileSpecified = true;
						try {
							files.push_back(new ClassInputStream(*new FileBinaryInputStream(arg)));
						} catch(const IOException& ex) {
							printError(ex.what());
						}
					}
				}

				#undef requireValue
				#undef printErrorAndExit

				instance = new JDecompiler(progName, files, atLeastOneFileSpecified, indent,
						failOnError, useConstants, useConstants == ConstantsUsage::ALWAYS && useCustomConstants, useHexNumbers,
						useShortArrayInitializing, canCastWrappers, canShowSynthetic, canShowBridge, canShowAutogenerated,
						canUseDoublePostfix, canUseTrailingZero, upperPostfixes, isMultilineStringAllowed, canUseOverrideAnnotation, classes);

				return true;
			}


			inline const char* getIndent() const {
				return indent;
			}

			inline bool isFailOnError() const {
				return failOnError;
			}

			inline bool canUseConstants() const {
				return useConstants == ConstantsUsage::ALWAYS;
			}

			inline bool canUseCustomConstants() const {
				return useCustomConstants;
			}

			inline bool canUseNaNAndInfinity() const {
				return useConstants == ConstantsUsage::ALWAYS || useConstants == ConstantsUsage::MINIMAL;
			}

			inline bool canUseHexNumbers() const {
				return useHexNumbers == HexUsage::AUTO || useHexNumbers == HexUsage::ALWAYS;
			}

			inline bool useHexNumbersAlways() const {
				return useHexNumbers == HexUsage::ALWAYS;
			}

			inline bool canUseShortArrayInitializing() const {
				return useShortArrayInitializing;
			}

			inline bool castWrappers() const {
				return canCastWrappers;
			}

			inline bool showSynthetic() const {
				return canShowSynthetic;
			}

			inline bool showBridge() const {
				return canShowBridge;
			}

			inline bool showAutogenerated() const {
				return canShowAutogenerated;
			}

			inline bool useDoublePostfix() const {
				return canUseDoublePostfix;
			}

			inline bool useTrailingZero() const {
				return canUseTrailingZero;
			}

			inline char getLongPostfix() const {
				return longPostfix;
			}

			inline char getFloatPostfix() const {
				return floatPostfix;
			}

			inline char getDoublePostfix() const {
				return doublePostfix;
			}

			inline bool multilineStringAllowed() const {
				return isMultilineStringAllowed;
			}

			inline bool useOverrideAnnotation() const {
				return canUseOverrideAnnotation;
			}


			inline const vector<ClassInputStream*>& getFiles() const {
				return files;
			}

			void readClassFiles() const;

			inline const map<string, const Class*>& getClasses() const {
				return classes;
			}

			inline const Class* getClass(const string& name) const {
				const auto& classIterator = classes.find(name);
				return classIterator != classes.end() ? classIterator->second : nullptr;
			}

			const ClassInfo* getClassInfo(const string& name) const;

			inline bool hasClass(const string& name) const {
				return getClass(name) != nullptr;
			}

		protected:
			template<typename Arg, typename... Args>
			static inline void print(ostream& out, Arg arg, Args... args) {
				if constexpr(sizeof...(Args) != 0)
					print(out << arg, args...);
				else
					out << arg << endl;
			}

		private:
			template<typename... Args>
			inline void error(Args... args) const {
				print(cerr << progName << ": error: ", args...);
			}
	};

	const JDecompiler* JDecompiler::instance = nullptr;
}

#endif
