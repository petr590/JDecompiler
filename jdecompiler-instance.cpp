#ifndef JDECOMPILER_JDECOMPILER_INSTANCE_CPP
#define JDECOMPILER_JDECOMPILER_INSTANCE_CPP

#include <filesystem>
#include <dlfcn.h>
#include "util.h"
#include "jvm.h"
#include "class-holder.cpp"

#ifndef JDECOMPILER_VERSION
#define JDECOMPILER_VERSION "unknown"
#endif

#ifdef __unix__
#	define LIBJVM_PATH "jvm.so"
#	define SYSTEM_LIBJVM_PATH "libjvm.so"
#elif defined(__WIN32) || defined(_WIN32)
#	define LIBJVM_PATH "jvm.dll"
#	define SYSTEM_LIBJVM_PATH "libjvm.dll"
#else
#	error "so far, Unsupported system: only windows and unix are supported"
#endif

namespace jdecompiler {

	namespace filesystem = std::filesystem;


	struct JDecompiler {

		protected:
			static const JDecompiler* instance;


			const string progName;

			const vector<ClassInputStream*> files;
			const bool atLeastOneFileSpecified;

			const bool canPrintClassVersion;

			const string indent;

			const bool canFailOnError;
			const bool canWriteToConsole;

			enum class ConstantsUsage { ALWAYS, MINIMAL, NEVER };
			const ConstantsUsage useConstants;
			const bool useCustomConstants;

			enum class HexUsage { ALWAYS, AUTO, NEVER };
			const HexUsage useHexNumbers;

			const bool canShowSynthetic, canShowBridge, canShowAutogenerated;
			const bool canUseDoublePostfix, canUseTrailingZero;
			const char longPostfix, floatPostfix, doublePostfix;

			const bool isMultilineStringAllowed;
			const bool canUseOverrideAnnotation;
			const bool canOmitReferenceToThis;

			const bool canUseShortArrayInitializing;
			const bool canUseCStyleArrayDeclaration;
			const bool canCastWrappers;
			const bool canPrintNewLineInParameterAnnotations;

			mutable umap<string, ClassHolder> decompilationClasses;
			mutable umap<string, const Class*> classes;

			friend struct Class;

		private:
			static const JVM* jvm;
			static void *libJvm, *systemLibJvm;
			friend void finish();

			const JVM* loadJvm(const char* javaHome) {

				if(javaHome == nullptr)
					return nullptr;

				/* I can't specify the LD_LIBRARY_PATH environment variable since it is not specified for the external context.
				 * Therefore, I have to load the libjvm library manually */
				static constexpr const char* SYSTEM_LIBJVM_PATHS[] = {
				#ifdef __unix__
						"/server/", "/lib/server/", "/lib/amd64/server/", "/jre/lib/amd64/server/"
				#else
				#	error "Other systems than unix are not supported yet"
				#endif
				};

				const size_t systemLibJvmPathOffset = javaHome[strlen(javaHome) - 1] == '/' ? 1 : 0;

				for(const char* systemLibJvmPath : SYSTEM_LIBJVM_PATHS) {
					char* fullPath = str_concat(javaHome, systemLibJvmPath + systemLibJvmPathOffset, SYSTEM_LIBJVM_PATH);
					systemLibJvm = dlopen(fullPath, RTLD_LAZY);
					delete[] fullPath;

					if(systemLibJvm != nullptr)
						break;
				}


				if(systemLibJvm == nullptr) {
					error("cannot load dynamic library " SYSTEM_LIBJVM_PATH ": ", dlerror());
					return nullptr;
				}


				// Load custom jvm library

				libJvm = dlopen(LIBJVM_PATH, RTLD_LAZY);

				if(libJvm == nullptr) {
					error("cannot load dynamic library " LIBJVM_PATH ": ", dlerror());
					return nullptr;
				}


				const JVM*(*createJvm)() = (const JVM*(*)())dlsym(libJvm, "createJDecompilerJvm");

				if(createJvm == nullptr) {
					error("cannot find function createJDecompilerJvm in library " LIBJVM_PATH ": ", dlerror());
					return nullptr;
				}

				return createJvm();
			}

		protected:
			JDecompiler(const string progName, const vector<ClassInputStream*>& files, bool atLeastOneFileSpecified, bool canPrintClassVersion,
					const string& indent, bool canFailOnError, bool canWriteToConsole, ConstantsUsage useConstants,
					bool useCustomConstants, HexUsage useHexNumbers, bool canShowSynthetic, bool canShowBridge, bool canShowAutogenerated,
					bool canUseDoublePostfix, bool canUseTrailingZero, bool upperPostfixes, bool isMultilineStringAllowed,
					bool canUseOverrideAnnotation, bool canOmitReferenceToThis, bool canUseShortArrayInitializing,
					bool canUseCStyleArrayDeclaration, bool canCastWrappers, bool canPrintNewLineInParameterAnnotations,
					const char* javaHome):

					progName(progName), files(files), atLeastOneFileSpecified(atLeastOneFileSpecified), canPrintClassVersion(canPrintClassVersion),
					indent(indent), canFailOnError(canFailOnError), canWriteToConsole(canWriteToConsole), useConstants(useConstants),
					useCustomConstants(useCustomConstants), useHexNumbers(useHexNumbers),
					canShowSynthetic(canShowSynthetic), canShowBridge(canShowBridge), canShowAutogenerated(canShowAutogenerated),
					canUseDoublePostfix(canUseDoublePostfix), canUseTrailingZero(canUseTrailingZero),
					longPostfix(upperPostfixes ? 'L' : 'l'), floatPostfix(upperPostfixes ? 'F' : 'f'), doublePostfix(upperPostfixes ? 'D' : 'd'),
					isMultilineStringAllowed(isMultilineStringAllowed), canUseOverrideAnnotation(canUseOverrideAnnotation),
					canOmitReferenceToThis(canOmitReferenceToThis),
					canUseShortArrayInitializing(canUseShortArrayInitializing), canUseCStyleArrayDeclaration(canUseCStyleArrayDeclaration),
					canCastWrappers(canCastWrappers), canPrintNewLineInParameterAnnotations(canPrintNewLineInParameterAnnotations) {

				jvm = loadJvm(javaHome);
			}



		public:
			static const JDecompiler& getInstance() {
				if(instance == nullptr)
					throw IllegalStateException("JDecompiler yet not initialized");
				return *instance;
			}

			static bool init(int argc, const char* args[]) {
				if(instance != nullptr)
					throw IllegalStateException("JDecompiler already initialized");

				const string progPath = args[0];
				const string progName = progPath.substr(progPath.find_last_of(filesystem::path::preferred_separator) + 1);

				vector<ClassInputStream*> files;

				bool canPrintClassVersion = true;

				string indent = "    ";

				bool canFailOnError = false;
				bool canWriteToConsole = false;
				ConstantsUsage useConstants = ConstantsUsage::ALWAYS;
				bool useCustomConstants = true;
				HexUsage useHexNumbers = HexUsage::NEVER;

				bool canShowSynthetic = false, canShowBridge = false, canShowAutogenerated = false;
				bool canUseDoublePostfix = true, canUseTrailingZero = false, upperPostfixes = false;

				bool isMultilineStringAllowed = true;
				bool canUseOverrideAnnotation = true;
				bool canOmitReferenceToThis = true;

				bool canUseShortArrayInitializing = true;
				bool canUseCStyleArrayDeclaration = false;
				bool canCastWrappers = true;
				bool canPrintNewLineInParameterAnnotations = true;

				const char* javaHome = getenv("JAVA_HOME");


				if(argc <= 1) {
					cout << "Usage: " << progName << " [options] <class-files>" << endl;
					return false;
				}

				#define printError(...) cerr << progName << ": error: " << __VA_ARGS__ << endl
				#define printErrorAndExit(...) { printError(__VA_ARGS__); return false; }

				#define requireValue() {\
					if(!hasValue) {\
						printErrorAndExit("option " << option << " required value");\
						return false;\
					}\
					i++;\
				}

				bool atLeastOneFileSpecified = false;

				for(int i = 1; i < argc; i++) {
					const string arg = args[i];
					const size_t length = arg.size();

					if(length > 1 && arg[0] == '-') {

						string option, value;
						bool hasValue = false, hasValueWeak = false;
						const auto splitpos = arg.find('=');

						if(splitpos != string::npos) {
							option = string(arg, 0, splitpos);
							value = string(arg.begin() + splitpos + 1, arg.end());
							hasValue = hasValueWeak = true;
						} else {
							option = arg;
							if(i + 1 < argc) {
								value = args[i + 1];
								hasValue = true;
							}
						}


						if(option == "-h" || option == "--help" || option == "-?") {
							cout << "Usage: " << progName << " [options] <class-files>\n"
							"\n"
							"----------------------------------------------- Options ------------------------------------------------\n"
							"General:\n"
							"  -h, --help, -?                        show this message and exit\n"
							"  -v, --version                         show program version\n"
							"  -f, --fail-on-error                   fail on error (debug)\n"
							//"  -d, --dir=<directory>                 specify directory to place decompiled files\n"
							"  --java-home=<path/to/java>            specify the java home path (if JAVA_HOME env var is not set)\n"
							"\n"
							"Decompilation of constants:\n"
							"  -c, --use-constants=auto|min|never    use constants:\n"
							"                                auto      use for all standart constants (MAX_VALUE, MIN_VALUE, etc.)\n"
							"                                 min      use for only POSITIVE_INFINITY, NEGATIVE_INFINITY and NaN\n"
							"                               never      don't use constants at all\n"
							"  --no-custom-consts                    don't use custom constants (which declared in decompiled class)\n"
							"  --min-consts                          the same as --use-constants=min\n"
							"  --no-consts                           the same as --use-constants=never\n"
							"\n"
							"  --synthetic                           show synthetic fields, methods and classes generated by compiler\n"
							"  --bridge                              show bridge methods generated by compiler\n"
							"  --autogenerated                       show methods autogenerated by compiler\n"
							"                                          (such as Enum.valueOf(String) or constructor by default)\n"
							"  -a, --all-autogenerated               show synthetic, bridge and autogenerated fields, methods and classes\n"
							"\n"
							"Text format:\n"
							"  -V, --no-print-version                  do not print class file version at the top of each file\n"
							"  -i=<indent>, --indent=<indent>          set indent (by default four spaces)\n"
							"  -t, --tab                               use tabs (equivalent to --indent='\\t')\n"
							"\n"
							"  -x, --hex[=always|auto|never]         use hex numbers:\n"
							"                              always      always use\n"
							"                                auto      only use for values like 0x7F, 0x80 and 0xFF\n"
							"                               never      do not use (by default)\n"
							"\n"
							"  -D  --no-double-postfix                 not use postfix 'd' in double literals\n"
							"  -u, --upper-postfixes                   use upper postfixes in long, float and double literals\n"
							"  -z, --use-trailing-zero                 use trailing zero in float or double literals if it is integral number\n"
							"                                             (note: if double literal has no prefix, trailing zero will be used in any case)\n"
							"  -M, --no-multiline                      not split multiline string constants\n"
							"  -O, --no-override-annotation            do not use java.lang.Override annotation\n"
							"  --this, --no-omit-this-ref              do not omit the reference to this\n"
							"\n"
							"  --no-short-array-init                   do not use short array initialization in the variable declaration\n"
							"  --c-style-arrays                        use C-style array declaration\n"
							"  --no-cast-wrappers                      do not replace methods such as Integer.valueOf and Integer.intValue\n"
							"                                            to cast to Integer and to int, respectively\n"
							"  --no-new-line-in-parameter-annotations  don't print new line when decompiling the annotation on the method argument\n"
							<< endl;

							return false;

						} else if(option == "-f" || option == "--fail-on-error") {
							canFailOnError = true;

						} else if(option == "--java-home") {
							requireValue();
							javaHome = strdup(value.c_str());

						} else if(option == "-o-") {
							canWriteToConsole = true;

						} else if(option == "-v" || option == "--version") {
							cout << "JDecompiler version " JDECOMPILER_VERSION << endl;

							return false;

						} else if(option == "-V" || option == "--no-print-version") {
							canPrintClassVersion = false;

						} else if(option == "-i" || option == "--indent") {
							requireValue();
							indent = unescapeString(value);

						} else if(option == "-t" || option == "--tab") {
							indent = "\t";

						} else if(option == "--use-constants") {
							requireValue();

							if(value == "always")
								useConstants = ConstantsUsage::ALWAYS;
							else if(value == "min")
								useConstants = ConstantsUsage::MINIMAL;
							else if(value == "never")
								useConstants = ConstantsUsage::NEVER;
							else
								printErrorAndExit("invalid value for option " << option << ": only valid always, min or never");

						} else if(option == "--no-custom-consts") {
							useCustomConstants = false;

						} else if(option == "--min-consts") {
							useConstants = ConstantsUsage::MINIMAL;

						} else if(option == "--no-consts") {
							useConstants = ConstantsUsage::NEVER;

						} else if(option == "-x" || option == "--hex") {
							if(hasValueWeak) {
								if(value == "always")     useHexNumbers = HexUsage::ALWAYS;
								else if(value == "auto")  useHexNumbers = HexUsage::AUTO;
								else if(value == "never") useHexNumbers = HexUsage::NEVER;
								else printErrorAndExit("invalid value for option " << option << ": only valid always, auto or never");
							} else {
								useHexNumbers = HexUsage::AUTO;
							}

						} else if(option == "--synthetic") {
							canShowSynthetic = true;
						} else if(option == "--bridge") {
							canShowBridge = true;
						} else if(option == "--autogenerated") {
							canShowAutogenerated = true;
						} else if(option == "-a" || option == "--all-autogenerated") {
							canShowSynthetic = true;
							canShowBridge = true;
							canShowAutogenerated = true;
						} else if(option == "-D" || option == "--no-double-postfix") {
							canUseDoublePostfix = false;
						} else if(option == "-z" || option == "--use-trailing-zero") {
							canUseTrailingZero = true;
						} else if(option == "-u" || option == "--upper-postfixes") {
							upperPostfixes = true;
						} else if(option == "-M" || option == "--no-multiline") {
							isMultilineStringAllowed = false;
						} else if(option == "-O" || option == "--no-override-annotation") {
							canUseOverrideAnnotation = false;
						} else if(option == "--this" || option == "--no-omit-ref-to-this") {
							canOmitReferenceToThis = false;
						} else if(option == "--no-short-array-init") {
							canUseShortArrayInitializing = false;
						} else if(option == "--c-style-arrays") {
							canUseCStyleArrayDeclaration = true;
						} else if(option == "--no-cast-wrappers") {
							canCastWrappers = false;
						} else if(option == "--no-new-line-in-parameter-annotations") {
							canPrintNewLineInParameterAnnotations = false;
						} else {
							printErrorAndExit("Unknown argument " << arg << "\n"
								"Use " << progName << " --help for more information");
						}
					} else {
						atLeastOneFileSpecified = true;
						try {
							files.push_back(new ClassInputStream(*new FileBinaryInputStream(arg)));
						} catch(const IOException& ex) {
							printError(ex.what());
						}
					}
				}

				#undef requireValue
				#undef printErrorAndExit

				instance = new JDecompiler(progName, files, atLeastOneFileSpecified, canPrintClassVersion, indent,
						canFailOnError, canWriteToConsole, useConstants, useConstants == ConstantsUsage::ALWAYS && useCustomConstants, useHexNumbers,
						canShowSynthetic, canShowBridge, canShowAutogenerated,
						canUseDoublePostfix, canUseTrailingZero, upperPostfixes,
						isMultilineStringAllowed, canUseOverrideAnnotation, canOmitReferenceToThis,
						canUseShortArrayInitializing, canUseCStyleArrayDeclaration, canCastWrappers, canPrintNewLineInParameterAnnotations, javaHome);

				return true;
			}


			inline bool printClassVersion() const {
				return canPrintClassVersion;
			}

			inline const string& getIndent() const {
				return indent;
			}

			inline bool failOnError() const {
				return canFailOnError;
			}

			inline bool writeToConsole() const {
				return canWriteToConsole;
			}

			inline bool canUseConstants() const {
				return useConstants == ConstantsUsage::ALWAYS;
			}

			inline bool canUseCustomConstants() const {
				return useCustomConstants;
			}

			inline bool canUseNaNAndInfinity() const {
				return useConstants == ConstantsUsage::ALWAYS || useConstants == ConstantsUsage::MINIMAL;
			}

			inline bool canUseHexNumbers() const {
				return useHexNumbers == HexUsage::AUTO || useHexNumbers == HexUsage::ALWAYS;
			}

			inline bool useHexNumbersAlways() const {
				return useHexNumbers == HexUsage::ALWAYS;
			}

			inline bool showSynthetic() const {
				return canShowSynthetic;
			}

			inline bool showBridge() const {
				return canShowBridge;
			}

			inline bool showAutogenerated() const {
				return canShowAutogenerated;
			}

			inline bool useDoublePostfix() const {
				return canUseDoublePostfix;
			}

			inline bool useTrailingZero() const {
				return canUseTrailingZero;
			}

			inline char getLongPostfix() const {
				return longPostfix;
			}

			inline char getFloatPostfix() const {
				return floatPostfix;
			}

			inline char getDoublePostfix() const {
				return doublePostfix;
			}

			inline bool multilineStringAllowed() const {
				return isMultilineStringAllowed;
			}

			inline bool useOverrideAnnotation() const {
				return canUseOverrideAnnotation;
			}

			inline bool omitReferenceToThis() const {
				return canOmitReferenceToThis;
			}

			inline bool useShortArrayInitializing() const {
				return canUseShortArrayInitializing;
			}

			inline bool useCStyleArrayDeclaration() const {
				return canUseCStyleArrayDeclaration;
			}

			inline bool castWrappers() const {
				return canCastWrappers;
			}

			inline bool printNewLineInParameterAnnotations() const {
				return canPrintNewLineInParameterAnnotations;
			}


			inline const vector<ClassInputStream*>& getFiles() const {
				return files;
			}

			void readClassFiles() const;

			inline const umap<string, ClassHolder>& getDecompilationClasses() const {
				return decompilationClasses;
			}

			inline const umap<string, const Class*>& getClasses() const {
				return classes;
			}

			inline const Class* getClass(const string& name) const {
				const auto& classIterator = classes.find(name);
				return classIterator != classes.end() ? classIterator->second :
						classes[name] = (jvm != nullptr ? jvm->loadClass(name.c_str()) : nullptr);
			}

			const ClassInfo* getClassInfo(const string& name) const;

			inline bool hasClass(const string& name) const {
				return getClass(name) != nullptr;
			}

		protected:
			template<typename Arg, typename... Args>
			static inline void print(ostream& out, Arg arg, Args... args) {
				if constexpr(sizeof...(Args) > 0)
					print(out << arg, args...);
				else
					out << arg << endl;
			}

		private:
			template<typename... Args>
			inline void error(Args... args) const {
				print(cerr << progName << ": error: ", args...);
			}
	};

	const JDecompiler* JDecompiler::instance = nullptr;
	const JVM* JDecompiler::jvm = nullptr;
	void *JDecompiler::libJvm = nullptr,
	     *JDecompiler::systemLibJvm = nullptr;
}

#endif
