#ifndef JDECOMPILER_METHOD_H
#define JDECOMPILER_METHOD_H

#include "code.h"

namespace jdecompiler {
	struct MethodDescriptor {
		public:
			const ReferenceType& clazz;
			const string name;
			const vector<const Type*> arguments;
			const Type* const returnType;

		private:
			enum class MethodType {
				CONSTRUCTOR, STATIC_INITIALIZER, PLAIN
			};

			const MethodType type;

			static MethodType typeForName(const string&);

		public:
			inline bool isConstructor() const {
				return type == MethodType::CONSTRUCTOR;
			}

			inline bool isStaticInitializer() const {
				return type == MethodType::STATIC_INITIALIZER;
			}

			MethodDescriptor(const ReferenceConstant* referenceConstant):
					MethodDescriptor(referenceConstant->clazz->name, referenceConstant->nameAndType) {}

			MethodDescriptor(const string& className, const NameAndTypeConstant* nameAndType):
					MethodDescriptor(className, nameAndType->name, nameAndType->descriptor) {}

			MethodDescriptor(const string& className, const string& name, const string& descriptor):
					MethodDescriptor(*parseReferenceType(className), name, descriptor) {}

			MethodDescriptor(const ReferenceType& clazz, const NameAndTypeConstant* nameAndType):
					MethodDescriptor(clazz, nameAndType->name, nameAndType->descriptor) {}

			MethodDescriptor(const ReferenceType& clazz, const string& name, const string& descriptor):
					MethodDescriptor(clazz, name, descriptor.c_str()) {}

			MethodDescriptor(const ReferenceType& clazz, const string& name, const char* descriptor):
					clazz(clazz), name(name), arguments(parseMethodArguments(descriptor)), returnType(parseReturnType(descriptor)), type(typeForName(name)) {}


			MethodDescriptor(const ReferenceType& clazz, const string& name, const Type& returnType, const initializer_list<const Type*> arguments):
					MethodDescriptor(clazz, name, &returnType, arguments) {}

			MethodDescriptor(const ReferenceType& clazz, const string& name, const Type* returnType, const initializer_list<const Type*> arguments):
					MethodDescriptor(clazz, name, returnType, vector<const Type*>(arguments)) {}

			MethodDescriptor(const ReferenceType& clazz, const string& name, const Type& returnType):
					MethodDescriptor(clazz, name, &returnType) {}

			MethodDescriptor(const ReferenceType& clazz, const string& name, const Type* returnType):
					clazz(clazz), name(name), arguments(), returnType(returnType), type(typeForName(name)) {}

			MethodDescriptor(const ReferenceType& clazz, const string& name, const Type* returnType, const vector<const Type*>& arguments):
					clazz(clazz), name(name), arguments(arguments), returnType(returnType), type(typeForName(name)) {}


		protected:
			string toString(const StringifyContext&, const Attributes&, size_t argsStart) const;

		public:
			virtual string toString(const StringifyContext&, const Attributes&) const;

			inline string toString() const {
				return clazz.getName() + '.' + name + '(' + join<const Type*>(arguments, [] (auto arg) { return arg->getName(); }) + ')';
			}


			inline bool equalsIgnoreClass(const MethodDescriptor& other) const {
				return  this == &other || (this->name == other.name &&
						*this->returnType == *other.returnType &&
						equal_values(this->arguments, other.arguments));
			}


			inline friend bool operator==(const MethodDescriptor& descriptor1, const MethodDescriptor& descriptor2) {
				return  &descriptor1 == &descriptor2 || (descriptor1.name == descriptor2.name && descriptor1.clazz == descriptor2.clazz &&
						*descriptor1.returnType == *descriptor2.returnType &&
						equal_values(descriptor1.arguments, descriptor2.arguments));
			}


			inline friend bool operator!=(const MethodDescriptor& descriptor1, const MethodDescriptor& descriptor2) {
				return !(descriptor1 == descriptor2);
			}


			inline friend ostream& operator<<(ostream& out, const MethodDescriptor& descriptor) {
				return out << descriptor.toString();
			}
	};


	struct Method: ClassElement {
		private:
			string errorMessage;

		public:
			const MethodDescriptor& descriptor;
			const Attributes& attributes;
			const CodeAttribute* const codeAttribute;
			const StringifyContext& context;

		protected:
			MethodScope& scope;

		private:
			bool isAutogenerated(const ClassInfo&) const;

		public:
			Method(uint16_t, const MethodDescriptor&, const Attributes&, const ClassInfo&);

			const StringifyContext& decompileCode(const ClassInfo&);

			virtual string toString(const ClassInfo&) const override;

			virtual bool canStringify(const ClassInfo&) const override;

			inline bool isStatic() const {
				return modifiers & ACC_STATIC;
			}

		private:
			FormatString modifiersToString(const ClassInfo&) const;
	};



	struct MethodDataHolder {
		public:
			const uint16_t modifiers;
			const MethodDescriptor& descriptor;
			const Attributes& attributes;

		#if 1
			MethodDataHolder(const ConstantPool& constPool, ClassInputStream& instream, const ClassType& thisType):
					modifiers(instream.readUShort()), descriptor(*new MethodDescriptor(thisType, constPool.getUtf8Constant(instream.readUShort()),
					constPool.getUtf8Constant(instream.readUShort()))),
					attributes(*new Attributes(instream, constPool, instream.readUShort(), AttributesType::METHOD)) {}

			MethodDataHolder(uint16_t modifiers, const MethodDescriptor& descriptor, const Attributes& attributes):
					modifiers(modifiers), descriptor(descriptor), attributes(attributes) {}

			inline const Method* createMethod(const ClassInfo& classinfo) const {
				return new Method(modifiers, descriptor, attributes, classinfo);
			}

		#else // Когда я включаю эту чать блока, появляется странный баг при декомпиляции enum-ов

		private:
			function<const Method*(const ClassInfo&)> defaultMethodCreator() {
				return [this] (const ClassInfo& classinfo) {
					return new Method(modifiers, descriptor, attributes, classinfo);
				};
			}

		public:
			const function<const Method*(const ClassInfo&)> createMethod;

			MethodDataHolder(const ConstantPool& constPool, ClassInputStream& instream, const ClassType& thisType):
					modifiers(instream.readUShort()), descriptor(*new MethodDescriptor(thisType, constPool.getUtf8Constant(instream.readUShort()),
					constPool.getUtf8Constant(instream.readUShort()))),
					attributes(*new Attributes(instream, constPool, instream.readUShort()), AttributesType::METHOD),
					createMethod(defaultMethodCreator()) {}

			MethodDataHolder(uint16_t modifiers, const MethodDescriptor& descriptor, const Attributes& attributes,
					const function<const Method*(const ClassInfo&)>& methodCreator):
					modifiers(modifiers), descriptor(descriptor), attributes(attributes), createMethod(methodCreator) {}

			MethodDataHolder(uint16_t modifiers, const MethodDescriptor& descriptor, const Attributes& attributes):
					MethodDataHolder(modifiers, descriptor, attributes, defaultMethodCreator()) {}
		#endif
	};
}

#endif
